% -*- TeX-master: "main"; fill-column: 72 -*-

\newcommand{\fixttspace}{\hspace*{1pt}}

\section{Package syntax and semantics}
\label{sec:syntax}

In this section, we define the syntax and semantics of the Hierarchical
Model Composition package for SBML Level~3 Version~1.  We expound on the
various data types and constructs defined in this package, then in
\sect{examples}, we provide complete examples of using the constructs in
example SBML models.

% -----------------------------------------------------------------------------
\subsection{Namespace URI and other declarations necessary for using this package}
\label{xml-namespace}

Every SBML Level~3 package is identified uniquely by an XML namespace
URI.  For an SBML document to be able to use a given SBML Level~3
package, it must declare the use of that package by referencing its URI.
The following is the namespace URI for this version of the Hierarchical
Model Composition package for SBML Level~3 Version~1:
\begin{center}
\uri{http://www.sbml.org/sbml/level3/version1/comp/version1}
\end{center}

In addition, SBML documents using a given package must indicate whether
understanding the package is required for complete mathematical
interpretation of a model, or whether the package is optional.  This is
done using the attribute \token{required} on the \token{<sbml>} element
in the SBML document.  For the Hierarchical Model Composition package,
the value of this attribute must be set to \val{true}.

The following fragment illustrates the beginning of a typical SBML model
using SBML Level~3 Version~1 and this version of the Hierarchical Model
Composition package:

\begin{example}
<?xml version="1.0" encoding="UTF-8"?>
<sbml xmlns="http://www.sbml.org/sbml/level3/version1/core" level="3" version="1"
      xmlns:comp="http://www.sbml.org/sbml/level3/version1/comp/version1" comp:required="true">
\end{example}
    

% -----------------------------------------------------------------------------
\subsection{Primitive data types}
\label{new-primitive-types}

Section~3.1 of the SBML Level~3 specification defines a number of
primitive data types and also uses a number of XML Schema 1.0 data
types~\citep{biron:2000}.  We assume and use some of them in the rest of
this specification, specifically \primtype{boolean}, \primtype{ID},
\primtype{SId}, \primtype{SIdRef}, \primtype{UnitSId},
\primtype{UnitSIdRef}, and \primtype{string}.  The Hierarchical Model
Composition package also makes use of or defines other primitive types;
they are described below.


\subsubsection{Type \fixttspace\primtypeNC{anyURI}}
\label{primtype-anyuri}
\label{primtype-uri}

Type \primtype{anyURI} is defined by XML Schema 1.0.  It is a character
string data type whose values are interpretable as URIs (\emph{Universal
  Resource Identifiers}; \citealt{harold:2001,w3c:2000}) as described by
the W3C document RFC~3986~\citep{rfc3986}.


\subsubsection{Type \fixttspace\primtypeNC{PortSId}}
\label{primtype-portid}

The type \primtype{PortSId} is derived from \primtype{SId} (SBML Level~3
Version~1 Core specification Section~3.1.7) and has identical syntax.
The \primtype{PortSId} type is used as the data type for the identifiers
of \Port objects (Section~\ref{port-class}) in the Hierarchical Model Composition
package.  The purpose of having a separate type for such identifiers is
to enable the space of possible port identifier values to be separated
from the space of all other identifier values in SBML.  The equality of
\primtype{PortSId} values is determined by an exact character sequence
match; i.e., comparisons of these identifiers must be performed in a
case-sensitive manner.


\subsubsection{Type \fixttspace\primtypeNC{PortSIdRef}}
\label{primtype-portidref}

Type \primtype{PortSIdRef} is used for all attributes that refer to
identifiers of type \primtype{PortSId}.  This type is derived from
\primtype{PortSId}, but with the restriction that the value of an
attribute having type \primtype{PortSIdRef} must match the value of a
\primtype{PortSId} attribute in the relevant model;  in other words, the value of
the attribute must be an existing port identifier in
the referenced model.  As with \primtype{PortSId}, the equality of
\primtype{PortSIdRef} values is determined by exact character sequence
match; i.e., comparisons of these identifiers must be performed in a
case-sensitive manner.


% -----------------------------------------------------------------------------
\subsection{The extended \class{SBML} class}
\label{sbml-class}
\label{listofmodeldefinitions-class}
\label{listofexternalmodeldefinitions-class}

The top level of an ``SBML document'' is a container whose structure is
defined by the object class \SBML in the SBML Level~3 specification.  In
Level~3 Core, this container can contain only one model, an object of
class \Model.  The Hierarchical Model Composition package allows SBML
documents to contain \emph{more} than one model.

To explain how this is accomplished, we first need to introduce some
terminology.  In the approach taken here, we make a distinction between
(a) the definition of a model, before it is actually used anywhere, and
(b) its actual use:

\begin{itemize}

\item The term \emph{model definition} refers to the former case; that
  is, the definition of a model, before it is used.  A model definition
  is akin to a Platonic ideal: it may be a complete model in and of
  itself, but until it is instantiated, it exists only as a concept.

\item The term \emph{submodel} refers to actual use of a model
  definition.  A submodel is an instantiation or instance of a
  previously-defined model: it is the realization of that model inside
  another model.  From the perspective of the model that contains this
  submodel, the model definition has come into being, and now exists as
  something that can be used (and possibly modified and adapted).

\end{itemize}

% [MH] Took this out because it wasn't clear that it was needed:
% 
% The potentially arbitrary nesting possible in model composition adds an
% additional wrinkle to the model definition/submodel distinction.  If the
% model directly containing a given submodel is the \Model object of the
% SBML document, then the submodel has been fully instantiated.  However,
% if the containing model is instead \emph{another} model definition (call
% it ``M''), the submodel becomes part of that larger model definition,
% but has \emph{not} been fully instantiated in the SBML document.  The
% submodel only becomes fully instantiated when the model definition
% (``M'') is itself instantiated in the top-level \Model object of an SBML
% document.

It may be helpful to contrast these terms with those in other
approaches to model composition.  Some approaches call the model
definitions themselves the ``submodels''.  We avoid that usage because,
in the present formulation, model definitions must be valid \Model
objects in and of themselves, and might never appear inside other models
in the SBML document where they are defined.  (This might be the
situation, for example, if the document defines multiple models purely
to serve as a sort of component library used by other files.)  We
reserve the term ``submodel'' specifically for the \emph{instance of a
  model inside a containing model}.  Another term used in other schemes
is ``model template'', which is close to what is intended by ``model
definition'' here, but ``template'' implies something that is incomplete
and needs to be filled in.  While this is possible in the approach
described here, it is not required; for example, in model aggregation,
several complete working models may be integrated to form a larger
whole.  We therefore eschew the term ``model template'' in favor of
\emph{model definition}.

\begin{figure}[b]
  \includegraphics{figs/hierarchical-sbml}
  \caption{The definitions of the extended \SBML class as well as the
    new classes \ListOfModelDefinitions,
    \ListOfExternalModelDefinitions, and \ExternalModelDefinition.  The
    extended \Model class is defined in \sect{model-class}.}
  \label{hierarchical-sbml-uml}
  \label{sbml-uml}
\end{figure}

\fig{hierarchical-sbml-uml} gives the definition of the extended
\SBML class that ties these different components together; it also
provides the definition of \ExternalModelDefinition.  Readers familiar
with the \SBML class in SBML Level~3 Core will notice that this package
adds two new lists, \token{listOfModelDefinitions} and
\token{listOfExternalModelDefinitions}, of class \ListOfModelDefinitions
and \ListOfExternalModelDefinitions, respectively.  The class diagram
also makes concrete the notions described above, that model definition
objects are not ``owned'' by any other model (they can be instantiated
anywhere, even by models in other files) and that they exist outside the
\Model class entirely.

\fig{hierarchical-sbml-uml} also makes clear how model definitions
\emph{are} \Model objects.  At the same time, the scheme preserves the
aspect of core SBML Level~3 in which a single \Model object appears at
the top level of an SBML document.  As will become when we define
\Model, submodels appear inside \Model objects.  This is a key feature
of the design described above; namely, when the top-level model
references submodels, the submodels are instantiated, whereas when a
model definition references submodels, the submodels are simply part of
that model definition---they are not instantiated until the model
definitions themselves are instantiated.

Finally, to give a more intuitive sense for how the pieces fit together,
\fig{hierarchy} below shows a template structure of an SBML document
with both a \token{listOfModelDefinitions} and
\token{listOfExternalModelDefinitions}, as well as a list of \Submodel
objects inside the \Model object.

\newcommand{\sayOptional}{\raisebox{0pt}[0pt][0pt]{\bigg\} \textrm{\emph{optional}}}}

\begin{figure}[hbt]
  \begin{tt}
    \examplespacing
    \small
    \fcolorbox{sbmlgray}{extremelylightgray}{%
      \begin{minipage}{\textwidth - 12pt}
        \begin{tabbing}
\=xx\=xx\=xx\=xx\=\kill
\+\>
<?xml version="1.0" encoding="UTF-8"?>\\
<sbml xmlns="http://www.sbml.org/sbml/level3/version1/core" level="3" version="1"\\
\>\>\>xmlns:comp="http://www.sbml.org/sbml/level3/version1/comp/version1" comp:required="true">\\[3pt]
\><model id="My\_Model">\\
\>\><comp:listOfSubmodels>\\
\>\>\>\textrm{\emph{one or more}} <comp:submodel> \ldots\ </comp:submodel> \textrm{\emph{elements}}  \` \sayOptional\\
\>\></comp:listOfSubmodels>\\
\></model>\\[3pt]
\><comp:listOfModelDefinitions>\\
\>\>\textrm{\emph{one or more}} <comp:modelDefinition> \ldots\ </comp:modelDefinition> \textrm{\emph{elements}}  \` \sayOptional\\
\></comp:listOfModelDefinitions>\\[3pt]
\><comp:listOfExternalModelDefinitions>\\
\>\>\textrm{\emph{one or more}} <comp:modelExternalDefinition> \ldots\ </comp:modelExternalDefinition> \textrm{\emph{elements}}  \` \sayOptional\\
\></comp:listOfModelDefinitions>\\[3pt]
</sbml>
        \end{tabbing}
      \end{minipage}
    }
  \end{tt}
  \vspace*{-2pt}
  \caption{Example of a skeleton SBML Level~3 document containing the
    possible top-level constructs defined by the Hierarchical Model
    Composition package.}
\label{hierarchy}
\end{figure}



\subsubsection{The lists of internal and external model definitions}

As shown in \fig{sbml-uml}, \token{listOfModelDefinitions} and
\token{listOfExternalModelDefinitions} are children of an extended \SBML
object.  Like other \textsf{\textbf{ListOf\rule{0.15in}{0.5pt}}} classes
in SBML, the \ListOfModelDefinitions and \ListOfExternalModelDefinitions
are derived from \SBase (more specifically, the extended \SBase class
defined in \sect{extended-sbase-class}).  They inherit \SBase's
attributes \token{metaid} and \token{sboTerm}, as well as the
subcomponents for \Annotation and \Notes, but they do not add any
especial attributes of their own.

If a model from an external SBML document is needed, it can be
referenced with an \ExternalModelDefinition object
(\sect{externalmodeldefinition-class}).  The
\ListOfExternalModelDefinitions container gathers all such references.
It is derived from \SBase but adds no especial attributes of its own.
Like the other \textsf{\textbf{ListOf\rule{0.15in}{0.5pt}}} classes, it
inherits the attributes \token{metaid} and \token{sboTerm}, as well as
the subcomponents for \Annotation and \Notes, that most SBML components
have.


\subsubsection{The \class{ExternalModelDefinition} class}
\label{externalmodeldefinition-class}

To describe model definitions contained in external documents, the
Hierarchical Model Composition package uses a separate object class
(\ExternalModelDefinition), defined in \fig{hierarchical-sbml-uml}.  In
the sense being used here, \ExternalModelDefinition objects are model
definitions---in and of themselves, they are definitions of models but
not \emph{uses} of those models.  The \ExternalModelDefinition provides
a way to declare and identify them so that the \Model object in the
present SBML document can use them in \Submodel objects.

\ExternalModelDefinition contains two required attributes
(\token{source} and \token{id}) and three optional attributes
(\token{modelRef}, \token{md5} and \token{name}).  These attributes are
explained below.


\paragraph{The \fixttspace\token{id} and \fixttspace\token{name} attributes}

The \token{id} attribute serves to provide a handle for the external
model reference so that \Submodel objects can refer to it.  (Crucially,
it is \emph{not} the identifier of the model being referenced; rather,
it is an identifier for this \ExternalModelDefinition object within the
current SBML document.)  The \token{id} attribute takes a required value
of type \primtype{SId}.

\ExternalModelDefinition also has an optional \token{name} attribute, of
type \primtype{string}.  The \token{id} attribute must be used as
described in \sect{namespaces}.  The \token{name} attribute may be used
in the same manner as other \token{name} attributes on SBML Level~3 Core
objects; see Section~3.3.2 of the SBML Level~3 Version~1 Core
specification for more information.


\paragraph{The \fixttspace\token{source} attribute}

The required attribute \token{source} is used to locate the SBML
document containing an external model definition.  The value of this
attribute must be of type \primtype{anyURI} (see \sect{primtype-uri}).
Since URIs may be either URLs, URNs, or relative or absolute file
locations, this offers flexibility in referencing SBML documents.  In
all cases, the \token{source} attribute value must refer specifically to
an SBML Level~3 Version~1 document; prior Levels/Versions of SBML are
not supported by this package.  The entire file at the given location is
referenced.  The \token{source} attribute must have a value for every
\ExternalModelDefinition instance.

Here are some examples of different \token{source} attribute values for
the different cases.  Suppose we have a model with the identifier
\val{glau} located in a file named \val{firefly.xml}.  The following
fragment defines an external model definition and gives it the
identifier \val{m1}, the latter being valid for use within the
containing SBML document:

\begin{example}
<comp:listOfExternalModelDefinitions>
    <comp:externalModelDefinition comp:source="firefly.xml" comp:modelRef="glau" comp:id="m1"/>
</comp:listOfExternalModelDefinitions>
\end{example}

(In the above, we assume the XML namespace prefix \val{comp} has been
assigned to the correct XML namespace URI for the Hierarchical Model
Composition package, but we do not show that part of the SBML document
here.  \sect{xml-namespace} explains this in more detail.)  On the other
hand, suppose that we wanted to reference the model defined as model
\val{BIOMD0000000002} in BioModels Database.  Looking inside the text of
that SBML document, it becomes evident that the model identifier (its
\token{id} value) is set to \val{mod}.  Thus, using a URN to reference
that model, we can write the following:

\begin{example}
<comp:listOfExternalModelDefinitions>
    <comp:externalModelDefinition comp:id="m2" comp:modelRef="mod"
                                  comp:source="urn:miriam:biomodels.db:BIOMD0000000002"/>
</comp:listOfExternalModelDefinitions>
\end{example}

Finally, we can imagine the situation where a model is made accessible
from a location accessible on the Internet, say via the HTTP protocol.
The following is a (fake) example:

\begin{example}
<comp:listOfExternalModelDefinitions>
    <comp:externalModelDefinition comp:id="m3" comp:modelRef="the_model_id"
                                  comp:source="http://www.cds.caltech.edu/~mhucka/sbmlmodel.xml"/>
</comp:listOfExternalModelDefinitions>
\end{example}



\paragraph{The \fixttspace\token{modelRef} attribute}

\ExternalModelDefinition's optional attribute \token{modelRef}, of type
\primtype{SIdRef}, in is used to identify a \Model object within the
SBML document located at \token{source}.  The object referenced may be
the main model in the document, or a model definition contained in the
SBML document's \token{listOfModelDefinitions} list.

In standard SBML, \token{id} on \Model is an optional attribute, and
therefore, it is possible that the \Model object in a given SBML
document does \emph{not} have an identifier.  In that case, there is no
value to give to the \token{modelRef} attribute in
\ExternalModelDefinition.  If \token{modelRef} does \emph{not} have a
value, then the main model (i.e., the \token{<model>} element within the
\token{<sbml>} element) in the referenced file is interpreted as being
the model referenced by this \ExternalModelDefinition instance.


\paragraph{The \fixttspace\token{md5} attribute}

The optional \token{md5} attribute takes a \primtype{string} value.  If
set, it must be an MD5 checksum value computed over the document
referenced by \token{source}.  This checksum can be used as a data integrity
check over the contents of the \token{source}.  Applications may use
this to verify that the contents have not changed since the time that
the \ExternalModelDefinition reference was constructed.  The procedure
for using the \token{md5} attribute is described in
\tab{md5-procedures}.

\begin{table}[thb]
  \begin{edtable}{tabular}{p{1in}l@{\hspace{0.75ex}}p{5in}}
    \toprule
    \textbf{Case} & \multicolumn{2}{l}{\textbf{Procedure}} \\
    \midrule
    Creating and writing & 1.& Compute the MD5 hash for the document located at \token{source}.\\
    an SBML document     & 2.& Store the hash value as the value of the \token{md5} attribute. \\
    \midrule
    Reading an SBML      & 1.& Read the value of the \token{md5} attribute.\\
    document             & 2.& Read the document at the location indicated by the
                                \token{source} attribute value.\\
                         & 3.& Compute the MD5 hash for the document.\\
                         & 4.& Compare the computed MD5 value to the value in the \token{md5} attribute.  
                         If they are identical, assume the document has not changed since the
                         time the \ExternalModelDefinition object was defined; if the values
                         are different, assume that the document indicated by \token{source}
                         has changed. \\
    \bottomrule
  \end{edtable}
  \caption{Procedures for using the \token{md5} attribute on
    \ExternalModelDefinition.} 
  \label{md5-procedures}
\end{table}

Software tools encountering a difference in the MD5 checksums should
warn their users that a discrepancy exists, because a difference in the
documents may imply a difference in the mathematical interpretation of
the models.

Note that the MD5 approach is not without limitations.  An MD5 hash is
typically expressed as a 32-bit hexadecimal number.  If a difference
arises in the checksum values, there is no way to determine the cause of
the difference without an component-by-component comparison of the
models.  (Even a difference in annotations, which cannot affect a models' mathematical
interpretations, will result in a difference in the MD5 checksum
values.)  On the other hand, it is also not impossible that two
different documents yield the \emph{same} MD5 hash value, although it is
extremely unlikely in practice.  In any event, the MD5 approach is
intended as an optional, simple and fast data integrity check, and not a
final answer.


% -----------------------------------------------------------------------------
\subsection{The extended \class{Model} class}
\label{model-class}
\label{listofsubmodels-class}
\label{listofports-class}

The extension of SBML Level~3 Core's \Model class is relatively
straightforward: the Hierarchical Composition Package adds two lists,
one for holding submodels (\token{listOfSubmodels}, of class
\ListOfSubmodels), and the other for holding ports (\token{listOfPorts},
of class \ListOfPorts).  \fig{extended-model-uml} provides the UML
diagram.  The rest of this section defines the extended \Model class and
the \Port class; \Submodel is defined in \sect{submodel-class}.

\begin{figure}[hbt]
  \vspace*{-1ex}
  \begin{overpic}{figs/extended-model-uml}
    \put(71,36.9){\emph{\sect{submodel-class}}}
    \put(88.75,23.75){\emph{\sect{sbaseref-class}}}
  \end{overpic}
  \caption{The extensions of the \Model class and the definitions of the
    classes \Port, \ListOfPorts, and \ListOfSubmodels.  \Submodel is
    defined in \sect{submodel-class} and \SBaseRef is defined in
    \sect{sbaseref-class}.  In other respects, \Model remains defined as
    in the SBML Level~3 Core specification.}
  \label{extended-model-uml}
  \label{port-uml}
\end{figure}


\subsubsection{The list of submodels}

The optional \token{listOfSubmodels} subcomponent in \Model holds a
\ListOfSubmodels container object.  If present, it must contain one or
more \Submodel objects (see \sect{submodel-class}).


\subsubsection{The list of ports}

The optional \token{listOfPorts} subcomponent in \Model holds a
\ListOfPorts container object.  If present, it must contain one or more
\Port objects (see \sect{submodel-class}).  Ports are described below.


\subsubsection{The \class{Port} class}
\label{port-class}

In Hierarchical Model Composition, the \emph{port} concept allows a
modeler to design a submodel such that other models interact with the
submodel through designated interfaces.  The intention is that a modeler
can indicate explicitly the intended points of interaction between a
given model and other models that include or otherwise interact with it.
The \Port class is defined in \fig{extended-model-uml}.  It is derived
from \SBaseRef, a class whose definition we leave to
\sect{sbaseref-class}; for now, it is worth mentioning that \SBaseRef
provides attributes \token{portRef}, \token{idRef}, \token{unitRef} and
\token{metaIdRef}, and a recursive subcomponent, \token{sbaseRef}.

We say that a \Port object instance \emph{defines a port} for a
component in a model.  As will become clear in \sect{sbaseref-class},
the facilities of the \SBaseRef parent class from which \Port is derived
are what provides the means for the component to be identified.  For
example, a port could be created by using the \token{metaIdRef}
attribute to identify the object for which a given \Port instance is the
port; then the question ``what does this port correspond to?'' would be
answered by the value of the \token{metaIdRef} attribute.

In the present formulation of the Hierarchical Model Composition
package, the use of ports is not \emph{enforced}, nor is there any
mechanism to restrict which ports may be used in what ways---they are
only an advisory construct.  Future versions of this SBML package may
provide additional functionality to support explicit restrictions on
port use.  For the present definition of Hierarchical Model Composition,
users of models containing ports are encouraged to respect the modeler's
intention in defining ports, and use the port definitions to interact
with components through their ports (when they have ports defined)
rather than interact directly with the components.


\paragraph{The \fixttspace\token{id} attribute}

The required attribute \token{id} is used to give an identifier to a
\Port object so that other objects can refer to it.  The attribute has
type \primtype{PortSId} and is essentially identical to the SBML
primitive type \primtype{SId}, except that its namespace is limited to
the identifiers of \Port objects defined within a \Model object.  In
parallel, the \primtype{PortSId} type has a companion type,
\primtype{PortSIdRef}, that corresponds to the SBML primitive type
\primtype{SIdRef}; the value space of \primtype{PortSIdRef} is limited
to \primtype{PortSId} values.  (See also \fig{sbaseref-uml}.)

Note the implication of the separate namespaces of port identifiers
(values of type \primtype{PortSId}) and other identifiers (values of
\primtype{SId} or \primtype{UnitSId}): since \primtype{PortSId} values
are in their own namespace within the parent \Model, it is possible for
a \primtype{PortSId} value to be the same as some \primtype{SId} value
in the model, without causing an identifier collision.


\paragraph{The \fixttspace\token{name} attribute}

The optional \token{name} attribute is provided on \Port so that port
definitions may be given human-readable names.  Such names may be useful
in situations when port names need to be displayed to modelers.


\paragraph{Additional restrictions on \class{Port} objects}

Several additional restrictions exist on the use of ports.  It will
immediately become apparent that these restrictions are common-sense
rules, but they are worth making explicit:

\begin{enumerate}

  \item The model to which a \Port object refers with its \SBaseRef constructs
    must be the parent \Model object containing the \Port object itself.

  \item Each port in a model must refer to a unique component of that
    model; that is, no two ports in a model may both refer to the same
    model component.

  \item A port cannot refer to another port of the same model.

  \item A port cannot refer to itself.
    
\end{enumerate}
  
% \token{metaIdRef} attribute's value must refer to a meta identifier of
% an object in the immediately-enclosing \Model object.  (For example, it
% could refer to the \token{metaid} attribute value of a \Species object
% defined elsewhere in the model.)  This is a further restriction to the
% space of values than what is defined by XML \primtype{IDREF} alone.  The
% reason is simply that it makes no sense to allow one \Model object to
% define a port on a \emph{different} \Model object.  This does not imply
% a restriction or modification of the \token{metaid} values of \SBase
% objects in an SBML document, nor does it negate the other properties of
% XML type \primtype{IDREF}; it merely reduces the set of valid values
% that can be chosen for a given \token{metaIdRef} attribute on \Port
% objects in an SBML document.
%
% --See the new paragraph at the end of the SBaseRef section--it says (briefly) what it says in the above commented-out paragraph, but applies to all SBaseRef objects.


% -----------------------------------------------------------------------------
\subsection{The \class{Submodel} class}
\label{submodel-class}
\label{listofdeletions-class}

In the SBML Hierarchical Model Composition package, submodels are
instantiations of models contained within other models.  Submodel
instances are expressed using objects of class \Submodel, defined in
\fig{submodel-uml}.  Objects of this class represent submodels contained
within \Model objects, as depicted in \fig{extended-model-uml}.

\begin{figure}[hbt]
  \begin{overpic}{figs/submodel-uml}
    \put(89.25,30.25){\emph{\sect{sbaseref-class}}}
  \end{overpic}
  \caption{The definition of the \Submodel, \Deletion and
    \ListOfDeletions classes.}
  \label{submodel-uml}
\end{figure}

A \Submodel object must say which \Model object it instantiates, and may
additionally define how the \Model object is to be modified before it is
instantiated in the enclosing model.  With respect to the latter
capability, this SBML package provides two possible types of direct
modifications: conversion factors, and deletions.  We describe these two
mechanisms in more detail in the subsections below, but the following
informal summary may serve as a useful guide to get a general sense for
how it things work:

\begin{itemize}

\item If numerical values in the referenced model must be changed in
  order to fit them into their new context as part of the submodel, the
  changes can be handled through conversion factors.

\item If one or more structural features in the referenced model are
  undesirable and should be removed, the changes can be handled through
  deletions.  (For example, an initial assignment or reaction not be
  relevant in its new context, and may need to be removed.)

\end{itemize}


\subsubsection{The attributes of \class{Submodel}}

\fig{submodel-uml} shows that \Submodel has numerous attributes, as well
as a single subcomponent, \token{listOfDeletions}.  We describe the
attributes below, then turn to \token{listOfDeletions} in
Sections~\ref{listofdeletions}--\ref{deletion-class}.


\paragraph{The \fixttspace\token{id} attribute}

The \token{id} is a required attribute of type \primtype{SId} that gives
an identifier to the \Submodel instance.  It is required so that other
references may always have a means through which a parent model may
refer to this submodel instance's elements (e.g., to link and replace
them).  The identifier has no mathematical meaning.

This identifier must follow the normal restrictions on SBML
\primtype{SId} values for uniqueness within \Model objects.  In
addition, the \token{id} value may not be referenced by SBML Level~3
Core components in a model.  For example, the identifier may not appear
as the \token{<ci>} value in a mathematical formula of a component
defined by SBML Level~3 Core (e.g., rules, initial assignments, etc.).
This restriction is necessary so that if a software package does not
have support for the Hierarchical Model Composition package, it can
ignore the package constructs and still end up with a syntactically
valid (though perhaps diminished) SBML document.


\paragraph{The \fixttspace\token{name} attribute}

The optional \token{name} attribute is provided on \Submodel so that
submodel definitions may be given human-readable names.  Such names may
be useful in situations when submodel names are displayed to modelers.


\paragraph{The \fixttspace\token{modelRef} attribute}
\label{submodel-modelref}
  
The whole purpose of a \Submodel object is to instantiate a model
definition, which is to say, either a \Model object defined in the same
enclosing SBML document, or a model defined in an external SBML
document.  The \token{modelRef} attribute is the means by which that
model is identified.  This required attribute of type \primtype{SIdRef},
must refer to the identifier of a \Model or \ExternalModelDefinition
object within the enclosing SBML document (i.e., in the model namespace
of the document).

It is perfectly legitimate for the model referenced by \token{modelRef}
to have its own submodels.  The composite model defined in that case is
simply the composed model that results from following the change of
inclusion.  However, there is one restriction: loops are not allowed.
In other words, the referenced model may not refer to its parent model,
nor may it refer to a model which in turn instantiates its parent model,
etc.

It is also legal for the model referenced by \token{modelRef} to refer
to the \token{<model>} child of the enclosing SBML document, i.e., the
main \Model object in the \SBML object where it is itself located.  This
would mean that the document contains a model definition that itself
contains (and perhaps modifies) the model it presents to the world as
the main or top-level model in the document.  A possible use for this
might be to define a common scenario in the main model, then create
alternate scenarios with different initial conditions or parameter sets
using the list of model definitions (\fig{hierarchical-sbml-uml}) in the
\SBML object.  Because the model namespace is defined per document, this
means that it is possible to define and include a new model namespace by
creating a new document, then importing one or more of those models
using the \ExternalModelDefinition class.  (\sect{namespaces} discusses
identifier scoping in more detail.)


\paragraph{The conversion factor attributes}
\label{submodel-conversion}

Conversion factors enable the matching up of mathematical values and
units of measurement between submodels and models.  There are six
possible conversion factors, corresponding to the six conversion factors
defined by SBML Level~3 Core's basic \Model object class.  The six
attributes representing these conversion factors on \Submodel are
\token{lengthConversionFactor}, \token{areaConversionFactor},
\token{volumeConversionFactor}, \token{substanceConversionFactor},
\token{timeConversionFactor}, and \token{extentConversionFactor}.

All of these optional attributes have type \primtype{SIdRef}.  If set,
the value must be the identifier of a \Parameter object in the parent
\Model object.  The parameter will be used to convert the value of the
submodel quantities of the indicated type (e.g., volume, time, etc.) to
the units used in the parent model.  The procedures are involved, and a
separate section (\sect{conversion-factors}) is devoted to explaining
them.


\subsubsection{The list of deletions}
\label{listofdeletions}

The \token{listOfDeletions} subcomponent on \Submodel holds an optional
\ListOfDeletions container which, if present, must contain one or more
\Deletion objects.  This list of deletions specifies objects to be
removed from the submodel when composing the overall model.  (This
``removal'' of course does not involve physically editing the files;
rather, it is mathematical and conceptual.)


\subsubsection{The \class{Deletion} class}
\label{deletion-class}

The \Deletion object class is used to define a \emph{deletion} operation
to be applied when a submodel instantiates a model definition.
Deletions may be useful in hierarchical model composition scenarios for
various reasons.  For example, some components in a submodel may be
redundant in the composed model, perhaps because the same features are
implemented in a different way in the new model.

Deletions function as follows.  When the \Model to which the \Submodel
object refers (via the \token{modelRef} attribute) is read and processed
for inclusion into the composed model, each \Deletion object identifies
an object to ``remove'' from that \Model instance.  The resulting
submodel instance consists of everything in the \Model object instance
\emph{minus} the entities referenced by the list of \Deletion objects.
We discuss the implications of deletions further below.

The definition of the \Deletion object class is shown in
\fig{submodel-uml}.  It is subclassed from \SBaseRef, described in
detail in \sect{sbaseref-class}, and reuses all the machinery provided
by \SBaseRef.  In addition, it defines two optional attributes,
\token{id} and \token{name}.


\paragraph{The \fixttspace\token{id} and \fixttspace\token{name} attributes}

The optional attribute \token{id} on \Deletion can be used to give an
identifier to a given deletion operation.  The identifier has no
mathematical meaning, but it may be useful for creating submodels that
can be manipulated more directly by other submodels.  (Indeed, it is
legitimate for an enclosing model definition to delete a deletion!)

The optional \token{name} attribute is provided on \Deletion for the
same reason it is provided on other elements that have identifiers;
viz., to provide for the possibility of giving a human-readable name to
the object.  The name may be useful in situations when deletions are
displayed to modelers.


\paragraph{Implications of a deletion}

As might be expected, deletions can have wide-ranging implications,
especially when the object deleted has substantial substructure, as in
the case of reactions.  The following are rules regarding deletions and
their effects.

\begin{enumerate}

\item An object that has been ``deleted'' is considered inaccessible.
  Any element that has been deleted (or replaced, as discussed in
  \sect{replacements}) may not be referenced by an \SBaseRef object.

\item If the deleted object has child objects and other structures, the
  child objects and substructure are also considered to be deleted.

\item It is not an error to delete explicitly an object that is already
  deleted by implication (for example as a result of point number 2
  above).  The resulting model is the same.

\end{enumerate}

We leave additional comments about best practices surrounding deletions
to \sect{best-practices-deletions}.

\clearpage


% -----------------------------------------------------------------------------
\subsection{Replacements}
\label{replacements}
\label{extended-sbase-class}

The model definition, submodel and port constructs defined so far allow
a modeler to identify and aggregate models, as well as (possibly) delete
features from model definitions before the definitions are used create a
final, composed model.  In this section, we turn to two final
capabilities needed for effective model composition: linking and
substituting components.  Both are implemented as \emph{replacements},
which are the glue used to connect submodels together with each other
and with a containing model.

Replacements are implemented by extending the SBML Level~3 Core \SBase
class as shown in \fig{extended-sbase-uml}.  This extension provides the
means to define replacements in two directions: either the current
object replaces one or more others, or the current object is itself
replaced by another.  These two possibilities are captured by the
\token{listOfReplacedElements} and \token{replacedBy} subcomponents
shown in \fig{extended-sbase-uml}.

\begin{figure}[hbt]
  \begin{overpic}{figs/extended-sbase-uml}
    \put(89,40.25){\emph{\sect{sbaseref-class}}}
  \end{overpic}
  \caption{The extension of \SBase and the definition of the
    \ListOfReplacedElements and \ReplacedElement classes.  The \SBaseRef
  class is defined in \sect{sbaseref-class}.}
  \label{extended-sbase-uml}
\end{figure}

Since \SBase in SBML is the abstract base class of all other SBML object
classes, the extension of \SBase means all SBML objects gain the ability
to define how they replace (or are replaced by) components in submodels.
Replacements are a general mechanism that serve multiple purposes.  At
their most basic, they allow a model builder to make a statement of the
form ``entity \emph{W} in this model replaces entity \emph{X} in
submodel \emph{Y}''.  In the final composed model, all references to
\emph{X} in \emph{Y} are replaced with references to \emph{W}.  The same
approach is used as the mechanism for linking or gluing entities from
different models together.  Thus, to connect entity \emph{X} and some
other entity \emph{Z} located in another submodel, a model could make
\emph{W} define multiple replacements simultaneously: one for \emph{X}
and another for \emph{Z}.  Entity \emph{W} will then act as an
intermediary at the level of the containing model.


\subsubsection{The list of replaced elements}

\fig{extended-sbase-uml} shows that the extension of \SBase by the
Hierarchical Model Composition package adds an optional
\token{listOfReplacedElements} subcomponent for holding a
\ListOfReplacedElements container object.  If present, it must contain
at least one \ReplacedElement object (\sect{replacedelement-class}).


\subsubsection{The \class{ReplacedElement} class}
\label{replacedelement-class}
\label{listofreplacedelements-class}

A \ReplacedElement object is essentially a pointer to a submodel object
that is should be considered ``replaced''.  The object \emph{holding}
the \ReplacedElement instance is the one \emph{doing the replacing}; the
object pointed to by the \ReplacedElement object is the object being
replaced.  A replacement implies that dependencies involving the
replaced object must be updated: all references to the replaced object
elsewhere in the model are taken to refer to the replacement object.
For example, if one species replaces another, then any reference to the
original species in mathematical formulas, or lists of reactants or
products or modifiers in reactions, or initial assignments, or any other
SBML construct, are taken to refer to the replacement species instead
(with its value possibly modified by either this object's
\token{conversionFactor} attribute or the relevant submodel's conversion
factors---see \sect{conversion-factors}).  Moreover, any annotations
that refer to the replaced species' \token{metaid} value must be made to
refer to the replacement species' \token{metaid} value instead; and
anything else that referred either to the object identifier (i.e., the
\token{id} attribute) or meta identifier (i.e., the \token{metaid}
attribute) must be made to refer to the replacement species object
instead.

\ReplacedElement inherits from \SBaseRef and adds three attributes: one
required (\token{submodelRef}) and two optional (\token{deletion} and
\token{conversionFactor}), as described below.


\paragraph{Attributes inherited from \class{SBaseRef}}

The \ReplacedElement class, being derived from \SBaseRef, inherits all
of that class' attributes and its subelement.  This means that
\ReplacedElement has the \token{portRef}, \token{idRef}, \token{unitRef}
and \token{metaIdRef} attributes, as well as the subcomponent
\token{sbaseRef} and the recursive structure that it implies.

It is the properties of \SBaseRef that allow a \ReplacedElement object
to refer to what is being replaced.  For example, if the object being
replaced has a port identifying it, the instance of \ReplacedElement
would have its \token{portRef} attribute value set to the identifier of
the \Port pointing to the object being replaced.  If there is no
corresponding port for the object being replaced, but the object has a
regular identifier (typically an attribute named \token{id}), then the
\ReplacedElement object would set \token{idRef} instead.  If there is no
identifier, the replacement would use the next available option defined
by \SBaseRef, and so on.  \sect{sbaseref-class} describes the
alternatives in more detail.


\paragraph{The \fixttspace\token{submodelRef} attribute}
\label{replacedelement-submodelref}

The required attribute \token{submodelRef} takes a value of type
\primtype{SIdRef}.  This value must be the identifier of a \Submodel
object in the containing model.  The \Model object referenced by the
\Submodel object establishes the object namespaces for the
\token{portRef}, \token{idRef}, \token{unitRef} and \token{metaIdRef}
attributes: only objects within the \Model object may be referenced by
those attributes.


\paragraph{The \fixttspace\token{deletion} attribute}
\label{replacedelement-deletion}

The optional attribute \token{deletion} takes a value of type
\primtype{SIdRef}.  The value must be the identifier of a \Deletion
object in the parent \Model of the \ReplacedElement (i.e., the value of
some \Deletion object's \token{id} attribute).  When \token{deletion} is
set, it means the \ReplacedElement object is actually an annotation to
indicate that the replacement object replaces something \emph{deleted}
from a submodel.  The use of the \token{deletion} attribute overrides
the use of the attributes inherited from \SBaseRef: instead of using,
e.g., \token{portRef} or \token{idRef}, the \ReplacedElement instance
sets \token{deletion} to the identifier of the \Deletion object.

The use of \ReplacedElement objects to refer to deletions has no effect
on the composition of models or the mathematical properties of the
result.  It serves instead to help record the decision-making process
that lead to a given model.  It can be particularly useful for
visualization purposes, as well as to serve as scaffolding where other
types of annotations can be added using the normal \Annotation
subcomponents available on all \SBase objects in SBML.

% Original text, some of which should go into the best practices:
%
% The most likely use case for this is in an 'N to M' replacement proposed
% by Andrew Finney ; perhaps an entire pathway is being replaced by a more
% detailed pathway with more reaction steps.  In this case, no one
% reaction step is replacing any one original reaction step, but the path
% as a whole is being conceptually replaced.  The way to implement this is
% to delete the original reaction steps from the submodel, and include the
% new reaction steps in the parent model.  If you wish to annotate those
% deletions, you may list the deletions as being replaced by elements of
% the new pathway.  This has no material effect on the model composition
% or on the math: it is merely a way to conceptually annotate the
% modeler's decision-making process.  As such, a deletion is the only type
% of Subelement that may be listed in more than one ListOfReplacements.
% It is recommended that in the above N to M scenario, all N deleted
% elements be listed under all M replacement elements, to make things
% easier on visualization software that may try to display the results.


\paragraph{The \fixttspace\token{conversionFactor} attribute}
\label{replacedelement-conversionfactor}

The \ReplacedElement class' \token{conversionFactor} attribute may be used to
define how to transform or rescale the replaced object's value so that
it is appropriate for the new contexts in which it appears.  The value
of this attribute must be of type \primtype{SIdRef} and refer to a
\Parameter object instance defined in the model.  The conversion factor
identified by the \token{conversionFactor} attribute overrides any
automatic conversion that may have been performed based on the
submodel's relevant conversion factors.  The details of this are left to
\sect{conversion-factors}.


\subsubsection{The \fixttspace\tokenNC{replacedBy} subcomponent}

As mentioned above, the extension of \SBase defined in
\fig{extended-sbase-uml} introduces a new optional subcomponent,
\token{replacedBy}.  Its value, if present on a given \SBase-derived
object, must be a single object of the \ReplacedBy class (described in
\sect{replacedby-class} below).


\subsubsection{The \ReplacedBy class}
\label{replacedby-class}

Whereas a \ReplacedElement object indicates that the containing object
replaces another, a \ReplacedBy object indicates the converse: the
present object is to replaced by another object.  As is the case with
\ReplacedElement, the \ReplacedBy class inherits from \SBaseRef.  It
adds one required attribute (\token{submodelRef}) and one optional
attribute (\token{conversionFactor}).


\paragraph{Attributes inherited from \class{SBaseRef}}

The \ReplacedBy class, being derived from \SBaseRef, inherits the latter
class' attributes \token{portRef}, \token{idRef}, \token{unitRef} and
\token{metaIdRef}, as well as the subcomponent \token{sbaseRef} and the
recursive structure that it implies.  


\paragraph{The \fixttspace\token{submodelRef} attribute}
\label{replacedby-submodelref}

The required attribute \token{submodelRef} takes a value of type
\primtype{SIdRef}, which must be the identifier of a \Submodel object in
the containing model.  This attribute is analogous to the corresponding
attribute on \ReplacedElement; that is, the model referenced by the
\Submodel object establishes the object namespaces for the
\token{portRef}, \token{idRef}, \token{unitRef} and \token{metaIdRef}
attributes: only objects within the \Model object may be referenced by
those attributes.


\paragraph{The \fixttspace\token{conversionFactor} attribute}
\label{replacedby-conversionfactor}

The \ReplacedBy class' \token{conversionFactor} attribute may be used to
define how to transform or rescale this object's value so that it is
appropriate for the new contexts in which it appears.  The value of this
attribute must be of type \primtype{SIdRef} and refer to a
\Parameter object instance defined in the model.  The conversion factor
identified by the \token{conversionFactor} attribute overrides any
automatic conversion that may have been performed based on the
submodel's relevant conversion factors.  The details of this are left to
\sect{conversion-factors}.


\subsubsection{Additional requirements and implications}
\label{replacedelement-additional}

Replacements are a powerful mechanism and carry significant
implications.  We focus on crucial ones below:

\begin{itemize}

\item \emph{Identifier references must be updated}.  Both
  \ReplacedElement and \ReplacedBy introduce the need to change
  identifier references that refer to the object being replaced.  This
  identifier-redirection process has some important implications.
  First, when anything refers to the replaced object's \token{id} and/or
  \token{metaid} value, the replacement object must itself define its
  own \token{id} and/or \token{metaid} value, or else the step of
  adjusting references will be impossible to perform because there will
  not be new \token{id} or \token{metaid} values to use in place of the
  old ones.  Second, if other SBML Level~3 packages attach identifiers
  in their own namespaces to an object being replaced, those identifiers
  must also be likewise redirected.  (And again, this implies that the
  SBML document must put suitable identifier attributes from those
  package namespaces on the \emph{replacement} object, so that the
  replacement object's identifiers can be substituted for those of the
  object being replaced.)

\item \emph{Subcomponents of a replaced object become inaccessible}.  An
  important and far-reaching consequence of replacements is that if the
  object being replaced contains other objects, then \emph{those other
    objects are considered deleted}.  For example, replacing a \Reaction
  or an \Event object means all of the substructure of those entities in
  a model are deleted, and references to the identifiers of those
  deleted entities are made invalid.  (This has implications for such
  things as \SpeciesReference identifiers that may be used in a model
  outside of the \Reaction objects where they are defined.)

\item \emph{Replacements must be unique}.  Unless the \token{deletion}
  attribute on the \ReplacedElement object is \val{true}, a given object
  being replaced may only appear in exactly one \ReplacedElement object
  anywhere in a model; otherwise, it would imply multiple entities
  replace the same object, and this would lead to ambiguities (e.g., in
  old references to the entities being replaced).  A \ReplacedElement
  object with \token{deletion}=\val{true} is the only type of entity
  that may be listed in more than one \ListOfReplacedElements.

\end{itemize}

This scheme does not provide for direct ``horizontal replacements''
involving only subelements.  An example might be when one species in one
submodel is the conceptual replacement for a second species in a second
submodel.  The lack of a direct mechanism for horizontal replacements is
not a true limitation; the same effect can be achieved by creating an
intermediate object in the containing model and linking it to the other
objects via replacements.

Finally, there is no requirement that replaced objects must be of the
same type as the replacing object.  The only restriction is that all old
references to the replaced object must now point to the replacing
object.  Of course, the normal rules of SBML validity apply, so the
resulting model must still make sense and be valid SBML.  There is no
requirement for like-kind replacements, however, because errors do not
\emph{necessarily} result.  For example, replacing a \Species object
that appeared in a \Reaction object would lead to an invalid SBML
document if the replacement was a \Parameter object, but replacing a
\Species object by a \Parameter could be valid if that \Species never
appeared in any \Reaction object or if all the \Reaction objects were
deleted.


% -----------------------------------------------------------------------------
\subsection{The \class{SBaseRef} class}
\label{sbaseref-class}

Defining ports, deletions, and replacements requires a way to refer to
specific components within enclosed models or even external models
located in other files.  The machinery for constructing such references
is embodied in the \SBaseRef class.  This class is the parent class of
the \Port, \Deletion, \ReplacedElement and \ReplacedBy classes described
in previous sections.

\fig{sbaseref-uml} shows the definition of \SBaseRef.  This class
includes several attributes used to implement alternative approaches to
referencing a particular component, and it also has a recursive
structure, providing the ability to refer to elements buried within
(say) a sub-submodel configuration.

\begin{figure}[hbt]
  \includegraphics{figs/sbaseref-uml}
  \caption{The extensions of the \SBaseRef class.  The four attributes
    \token{portRef}, \token{idRef}, \token{unitRef} and \token{metaIdRef}
    are mutually exclusive; only one can have a value in a given object
    instance.  The recursive structure also allows referencing entities
    in submodels of submodels, to arbitrary depths, as described in the
    text.}
  \label{sbaseref-uml}
\end{figure}


\subsubsection{The attributes of \class{SBaseRef}}

The four different attributes on \SBaseRef are mutually exclusive: only
one of the attributes can have a value at any given time, and exactly
one must have a value in a given \SBaseRef object instance.  (Note that
this is true of the basic \SBaseRef class; however, derived classes such
as \ReplacedElement may add additional attributes and extend or override
the basic attributes and mechanisms.)

All of the attributes face the following common namespace issue.  As
discussed in more detail in \sect{namespaces}, attributes of type
\primtype{SId}, \primtype{UnitSId}, and \primtype{PortSId} need only be
unique on a per-\Model basis.  This means that an interpreter of the
SBML document must be able to determine the model to which
\token{idRef}, \token{unitRef}, and \token{portRef} attributes refer.
In addition, even though \primtype{ID} values are unique on per-document
level, the same SBML element may be instantiated in multiple submodels,
in any number of \Model objects, and therefore the \token{metaIdRef}
attribute must also know to which \Model instantiation it is referring.
Just exactly how this is done is something that is left up to the
classes that subclass \SBaseRef.  The sections that describe \Port,
\Deletion, \ReplacedElement and \ReplacedBy describe the approach taken
in each case.

Separately, readers may wonder why so many different alternatives are
necessary.  The reason is that in a given scenario, the referenced model
may be located in an external file beyond the direct control of the
modeler, and so the preferred methods of referencing the subobjects may
not be available.  \SBaseRef provides multiple alternatives so that a
variety of modeling scenarios can be supported.


\paragraph{The \fixttspace\token{portRef} attribute}
\label{sbaseref-portref}

The optional attribute \token{portRef} takes a value of type
\primtype{PortSIdRef}.  As its name implies, this attribute is used to
refer to a port identifier, in the case when the reference being
constructed with the \SBaseRef is intended to refer to a port on a
submodel.  The namespace of the \primtype{PortSIdRef} value is the set
of identifiers of type \primtype{PortSId} defined in the submodel, not
the parent model.


\paragraph{The \fixttspace\token{idRef} attribute}
\label{sbaseref-idref}

The optional attribute \token{idRef} takes a value of type
\primtype{SIdRef}.  As its name implies, this attribute is used to
refer to a regular identifier (i.e., the value of an \token{id}
attribute on some other object), in the case when the reference being
constructed with the \SBaseRef is intended to refer to an object that
does not have a port identifier.  The namespace of the \primtype{SIdRef}
value is the set of identifiers of type \primtype{SId} defined in the
submodel, not the parent model.


\paragraph{The \fixttspace\token{unitRef} attribute}
\label{sbaseref-unitref}

The optional attribute \token{unitRef} takes a value of type
\primtype{UnitSIdRef}.  This attribute is used to refer to the identifier
of a \UnitDefinition object.  The namespace of the \primtype{UnitSIdRef}
value is the set of unit identifiers defined in the submodel, not the
parent model.

Note that even though this attribute is of type \primtype{UnitSIdRef},
the reserved unit identifiers that are defined by SBML Level~3 (see
Section~3.1.10 of the SBML Level~3 Version~1 core specification) are
\emph{not} permitted as values of \token{unitRef}.  Reserved unit
identifiers may not be replaced or deleted.


\paragraph{The \fixttspace\token{metaIdRef} attribute}
\label{sbaseref-metaidref}

The optional attribute \token{metaIdRef} takes a value of type XML
\primtype{IDREF}.  This attribute is used to refer to a \token{metaid}
attribute value on some other object, in the case when the reference
being constructed with the \SBaseRef is intended to refer to an object
that does not have a port identifier.  Since meta identifiers are
optional attributes of \SBase, all SBML objects have the potential to
have a meta identifier value.


\subsubsection{Recursive \class{SBaseRef} structures}
\label{sbaseref-recursive-sbaseref}

An \SBaseRef object may have up to one subcomponent named
\token{sbaseRef}, of type \SBaseRef (see \fig{sbaseref-uml}).  This
arrangement permits recursive structures to be constructed so that
objects inside submodels can be referenced.

The form of such recursive references must be as follows.  The
highest-level \SBaseRef object of such a chain (which will necessarily
be an object of class \Port, \Deletion, \ReplacedElement or \ReplacedBy,
because they are the only classes derived from the class \SBaseRef) must
refer to a \Submodel object in the containing model.  All child
\SBaseRef objects in the chain must refer to components inside the
\Model instance to which the \Submodel refers.

The following example may help clarify this.  Suppose that we want to
delete an object with the identifier \val{p1} inside the \Submodel
object identified as \val{m1}.  \fig{submodel-uml} shows that \Deletion
objects are placed inside a \ListOfDeletions.  The following XML
fragment illustrates how the constructs will look:

\begin{example}
<listOfDeletions>
  <deletion idRef="m1">
    <sbaseRef idRef="p1" />
  </deletion>
</listOfDeletions>
\end{example}

Suppose instead that the submodel \val{m1} from the previous example is
actually nested inside another submodel \val{m2}.  Then, we would have
the following:

\begin{example}
<listOfModelDefinitions>
  <modelDefinition id="m1">
    <listOfParameters>
      <parameter id="p1" value="3"/>
    </listOfParameters>
  </modelDefinition>
  <modelDefinition id="m2">
    <listOfSubmodels>
      <submodel id="sub_m1" modelRef="m1"/>
    </listOfSubmodels>    
  </modelDefinition>
  <modelDefinition id="m3">
    <listOfSubmodels>
      <submodel id="sub_m2" modelRef="m2">
        <listOfDeletions>
          <deletion idRef="sub_m1">
            <sbaseRef idRef="p1" />
          </deletion>
        </listOfDeletions>
      </submodel>
    </listOfSubmodels>    
</listOfModelDefinitions>
\end{example}

Finally, what if we needed to go further down into nested submodels?
The following example illustrates this:

\begin{example}
<listOfModelDefinitions> 
  <modelDefinition id="m1"> 
    <listOfParameters> 
      <parameter id="p1" value="3"/> 
    </listOfParameters> 
  </modelDefinition> 
  <modelDefinition id="m2"> 
    <listOfSubmodels> 
      <submodel id="sub_m1" modelRef="m1"/> 
    </listOfSubmodels>     
  </modelDefinition> 
  <modelDefinition id="m3"> 
    <listOfSubmodels> 
      <submodel id="sub_m2" modelRef="m2"/> 
    </listOfSubmodels>     
  </modelDefinition> 
  <modelDefinition id="m3"> 
    <listOfSubmodels> 
      <submodel id="sub_m2" modelRef="m3"> 
        <listOfDeletions> 
          <deletion idRef="sub_m1"> 
            <sbaseRef idRef="sub_m2"> 
              <sbaseRef idRef="p1" />
            </sbaseRef> 
          </deletion> 
        </listOfDeletions> 
      </submodel> 
    </listOfSubmodels>     
</listOfModelDefinitions> 
\end{example}


Although this use of nested \SBaseRef objects allows a model to refer to
components buried inside submodels, it is considered inelegant model
design.  It is better to promote any element in a submodel to a local
element if it can be predicted that containing models may need to
reference it.  However, if the submodel is fixed (e.g., if is in an
external file), then no other option may be available except to use
nested references.



% -----------------------------------------------------------------------------
\subsection{Conversion factors}
\label{conversion-factors}

\draftnote{[MH] I have not looked at this section.}
In SBML Level~3 Version~1 Core, units of measurement are optional
information.  Modelers are required to write their models in such a way
that all conversions between units are explicitly incorporated into the
quantities, so that nowhere do units need to be understood and values
implicitly converted before use.  Given the Hierarchical Model
Composition package's design goal of compatibility with existing models
and files that may not be changeable, it is not an option to require
that all included models must be written in such a way that they are
numerically compatible with each other.  For example, if one submodel
defines how a species amount changes in time, and a second submodel
defines an initial assignment for that same species in terms of
concentration, something must be done to make the model as a whole
coherent without editing the submodels directly.  That is the purpose of
the conversion factor attributes on the \Submodel and \ReplacedElement
classes.

There are many situations to account for, so unfortunately, the topic of
conversion factors is rather involved.  We begin with the relatively
straightforward case of \ReplacedElement.


\subsubsection{Conversion factors involving \class{ReplacedElement}}

As explained in \sect{replacedelement-class}, the various conversion
factor attributes on \ReplacedElement override any conversion factors
defined on the \Submodel object that the \ReplacedElement references via
its \token{modelRef} attribute.

If the submodels of the merged model retain any mathematical formulas
(that is, if there are any reactions, assignments, or any other
construct with a MathML \token{<math>} element that has not been
replaced or deleted from the submodel), then those formulas may be
subject to different scales and units than the mathematical formulas of
the containing model.  In that case, the entities and formulas should be
converted to the new units.  If a replaced element has a defined
conversion factor, then any time a calculation is performed within the
math of the \Submodel object where the replaced element's identifier is
found on the left-hand side of an equation, the right-hand side is
multiplied by that conversion factor before assignment to that variable.
For example, if a species has an initial assignment of $4x + 3$, and has
a conversion factor of $c$, the initial assignment formula become
$c (4x+3)$.  The same is true for assignment rules, rate
rules, kinetic laws, event assignments, and the implied rates of change
of species as calculated from kinetic laws, as described in section
4.11.7 of the SBML Level~3 Version~1 Core specification.

Conversely, wherever the identifier of a replaced element appears on the
right-hand side of an equation in its original submodel, its appearance
in that equation should be \emph{divided} by the conversion factor.  In
our previous example of an initial assignment of $4x+3$, if the $x$ had
been replaced and given a conversion factor of $c_x$, that initial
assignment formula would become $4(x/c_x)+3$.  This holds true for any
mathematical equation in the model, including algebraic rules.  This
also means that if a value appears on the right and left-hand sides of
an equation, you must apply the conversion factor twice: if the rate
rule of $x$ is $4x+3$, it becomes $c_x(4(x/c_x) + 3)$.  (This
simplifies to $4x + 3c_x$, as you would expect---the $x$ is already in
the correct scale; it is only the 3 that must be converted.)

% The situation becomes trickier when talking about implied units of model
% elements.  The SBML Level~2 specification defined what the 'base units'
% of the model were, even if none were defined in the model itself.  SBML
% Level 3 no longer does this, but it retains the concept of unit types
% for certain elements, even if those units are left undefined.  A
% compartment with 'spatialDimensions=3' is of the unit type 'volume', for
% example, even if exactly what units those are (liters; millicubits3;
% etc.) is left undefined.  Similarly, all species are either of the unit
% type 'substance' or 'concentration', depending on the value of the
% required Boolean attribute 'hasOnlySubstanceUnits'.  ('Concentration'
% is, in turn, defined as 'substance divided by the units of the
% containing compartment'.)  Rate rules of elements are defined as the
% unit of that element divided by time.  The implied equations derived
% from reactions (see section 4.11.7 of the core specification) are
% defined as being substance over time.  Regardless of what those units
% are defined to be, or even if those units are left undefined, the unit
% types are set, and must be consistent throughout the model, so nothing
% is implicitly converted.


\subsubsection{Conversion factors involving \class{Submodel}}

The six attributes on \Submodel with the names of the form
\token{\rule{0.2in}{0.5pt}ConversionFactor} dictate how any submodel
mathematics whose unit types are defined by the Level~3 Core
specification are to be converted whether or not that element was
replaced, in the absence of an explicit conversion factor for that
element.  To understand the rules, it is first helpful to have a summary
of the conversion factors implied by the SBML Level~3 Version~1 Core
specification.  We provide a summary in \tab{sbml-conversions}.

\newcommand{\sprd}[2]{\raisebox{-#1pt}[0pt][(#1pt * 2) + 4pt]{#2}}
\newcommand{\persymb}{\emph{Conversion factor for referenced object}}
\newcommand{\percomp}{\emph{Conversion factor for compartment}}
\newcommand{\allat}{\emph{(All)}}
\newcommand{\hosu}{\token{hasOnlySubstanceUnits}}

\begin{table}[bht]
  \rowcolors{2}{sbmlrowgray}{}
  \renewcommand{\arraystretch}{1.175}
  \begin{edtable}{tabular}{p{1.1in}p{2.57in}l}
    \toprule
    \textbf{Component}	& \textbf{Attribute value}	& \textbf{Automatic conversion factor}\\
    \midrule
    \AlgebraicRule	& \allat			& 1\\
    \AssignmentRule	& \allat			& \persymb\\
    \Compartment	& \token{spatialDimensions}=\val{1}	& \token{lengthConversionFactor}\\
    \Compartment	& \token{spatialDimensions}=\val{2}	& \token{areaConversionFactor}\\
    \Compartment	& \token{spatialDimensions}=\val{3}	& \token{volumeConversionFactor}\\
    \Compartment	& \token{spatialDimensions} not equal to \val{1}, \val{2}, or \val{3} & 1\\
    \Constraint		& \allat			& \emph{(None needed)}\\
    \Delay		& \allat			& \token{timeConversionFactor}\\
    \EventAssignment	& \allat			& \persymb\\
    \FunctionDefinition	& \allat			& 1\\
    \InitialAssignment	& \allat			& \persymb\\
    \sprd{4}{\KineticLaw} & \sprd{4}{\allat}		& \sprd{4}{$\frac{\token{extentConversionFactor}}{\token{timeConversionFactor}}$}\\
    Implied rate of change of a species	& \sprd{4}{\allat}		& \sprd{4}{$\frac{\token{substanceConversionFactor}}{\token{timeConversionFactor}}$}\\
    \Parameter		& \allat			& 1\\
    \Priority		& \allat			& 1\\
    \sprd{4}{\RateRule} & \sprd{4}{\allat}		& \sprd{4}{$\frac{\textsf{\persymb}}{\token{timeConversionFactor}}$}\\
    \Species		& \hosu=\val{true}		& \token{substanceConversionFactor}\\
    \sprd{4}{\Species}	& \sprd{4}{\hosu=\val{false}}	& \sprd{4}{$\frac{\token{substanceConversionFactor}}{\textsf{\persymb}}$}\\
    \sprd{6}{\Species}	& \hosu=\val{true} replaced by a \Species having \hosu=\val{false}
	    & \sprd{6}{$\frac{\token{substanceConversionFactor}}{\textsf{\emph{Compartment size}}}$}\\
    \sprd{6}{\Species}	& \hosu=\val{false} replaced by a \Species having \hosu=\val{true}
	    & \sprd{6}{$\frac{\token{substanceConversionFactor} \,\cdot\, \textsf{\emph{(Compart. size)}}}{\percomp}$}\\
    \SpeciesReference	& \allat			& 1\\
    \Trigger		& \allat			& \emph{(None needed)}\\
    (Unknown)		& \allat			& 1\\
    \bottomrule
  \end{edtable}
  \caption{Conversion factors used for the different components defined
    by SBML Level~3 Core.}
  \label{sbml-conversions}
\end{table}

The procedures for using the conversion factor attributes on \Submodel
are based on the conversion factors defined by the Core.  Thus, all
compartments that set \token{spatialDimension}=\val{1} in the submodel
must be converted according to the \token{lengthConversionFactor}, with
all assignments to that compartment multiplied by the conversion factor,
and that compartment's identifier divided by it wherever it appears
inside a math element.  All rates of change of species amounts (defined
in section 4.11.7 of the Level~3 Version~1 Core specification) are
converted by the \token{substanceConversionFactor} divided by the
\token{timeConversionFactor}, after being converted (if necessary) by
any internal conversion factors, as described.  All species
concentrations from compartments of dimension 2 are converted by the
\token{substanceConversionFactor} divided by the
\token{areaConversionFactor}.  Non-replaced elements with defined unit
types are still converted, so that the output of any simulation will be
on the same scale as elements from the containing model.

In the core specification for SBML Level 3, if the conversion factor
attributes for \Model and \Species are undefined, the rate of change of
species amounts over time is defined to be equal to the rate of extent
of the reaction over time, arguably creating a default conversion of
extent to amount of 1.  Similarly, all conversion factors here
effectively default to '1' as well, so that if (for example)
'substanceConversionFactor' is defined but 'areaConversionFactor' is
not, species concentrations from compartments of dimension 2 are still
converted according to the substanceConversionFactor, 'divided by 1'.

Critically, if an element's unit type cannot be determined, it has no
default conversion factor, and one must be set explicitly for the
element in question.  All \Parameter objects fall into this category, as
parameters may have any unit at all, and have no defined unit type as a
class.  Similarly, compartments with no \token{spatialDimension} set, or
set to a fractal \token{spatialDimension} such as 2.6 should not be
converted automatically.  This means that if a parameter is internal to
a submodel and not replaced, there is no way to convert it, and it will
remain in its original scale.  This will not affect the math of the
converted elements, as the rules above first convert all math to the
original scale, and only convert it to the new scale when assigning it
to a variable.  However, if it is displayed as output, these values may
be in a different scale from other displayed output.  The only way to
correct this situation is to replace the parameter in question, and give
it an explicit conversion factor.

Some math may use a combination of conversion factors defined on the
\Submodel object with the conversion factors defined explicitly on an
element's replacement construct.  The simplest example is that of a rate
rule that defines how a parameter changes with time.  If the \Parameter
object has been replaced and given a conversion factor, the parameter's
explicit conversion factor is divided by the submodel's
\token{timeConversionFactor} to act as the overall conversion factor for
the rate rule's formula.  As a slightly more complicated example, a
species concentration that has no explicit conversion factor set for its
replacement, and which is contained in a compartment that does have an
explicit conversion factor, will be converted according to the
\token{substanceConversionFactor} from the \Submodel object divided by
the conversion factor defined by the compartment replacement construct.

Species concentrations of species from compartments with undefined unit
types will be converted according to the
\token{substanceConversionFactor} alone, if no conversion factor is
defined for its compartment.  An odd potential situation arises here in
the case where the species' compartment has been actually deleted
instead of replaced, the replacement species being put into a new
compartment in the containing model.  In this case, no automatic
conversion factor is possible, and if one is needed, it must be set
explicitly on the species' replacement itself.  Another complication is
the situation where a species is set
\token{hasOnlySubstanceUnits}=\val{true} in the submodel, but is set
\token{hasOnlySubstanceUnits}=\val{false} in its replacement, or vice
versa.  In this case, the species must be converted according to the
actual value of its compartment.  If an explicit conversion factor is
set, it is assumed that the modeler took this into consideration, and
created an assignment rule (or similar) such that the conversion
parameter would function appropriately.  If not, the automatic
conversion must use the value for the compartment of the replacement
species to convert the species values to amounts from concentrations,
and back again.  Unreplaced species are still converted, but if they
were in amounts before, they remain in amounts afterwards and likewise
when in concentrations.

Any math not directly associated with a replaced element and that does
not have a defined unit type is assumed to exist in the same scale as
all other similar elements across all submodels.  The only example of
this in the Level~3 Core is the math associated with the \Priority
subcomponent of \Event objects.  A \Priority element may be replaced
directly by a \ReplacedElement construct or by replacing its parent
\Event, but when comparing priority expressions from submodels with
priority expressions from the containing model or from other submodels,
they are all assumed to be on the same scale relative to each other.
(If one model had priorities set on a scale of 0 to 10 and another had
priorities set on a scale of -100 to 100, that is just the way it is,
and to fix it, all incompatible priorities would have to be replaced.)
The same would be true of math defined in any other Level~3 package
without a defined unit type, or with a newly-defined unit type: none of
it would be converted automatically, and all such elements would have to
be converted explicitly by being replaced, or that package would have to
extend this Hierarchical Model Composition package to define a new
attribute on Submodel that could be used to automatically convert all
such elements in the submodel with that unit type.


\clearpage

% -----------------------------------------------------------------------------
\subsection{Namespace scoping rules for identifiers}
\label{namespaces}

In the Hierarchical Model Composition package, as in SBML Level~3
Version~1 Core, the \Model object contains the main components of an
SBML model, such as the species, compartments and reactions.  The
package adds the ability to put \emph{multiple} models inside an SBML
document, and therefore must define the scope of identifiers in such a
way that identifier collisions are prevented.  In this section, we
describe the scoping rules for all of the types and classes defined in
Sections~\ref{new-primitive-types}--\ref{sbaseref-class}.

\begin{enumerate}

\item A shared namespace exists for \primtype{SId} values defined at the
  level of the SBML document.  This namespace applies to the identifiers
  (i.e., values of \token{id} attributes) of all \Model and
  \ExternalModelDefinition objects within the SBML document.  (An
  \ExternalModelDefinition object references a model elsewhere, so in
  this sense, both \Model and \ExternalModelDefinition are types of
  models.)  The identifier of every \Model and \ExternalModelDefinition
  object must be unique across the set of all such identifiers in the
  document.  The namespace is limited to that SBML document, and is not
  shared with any other SBML document, even if that document is
  referenced via an \ExternalModelDefinition.  This namespace is known
  as \emph{the model namespace of the document}.

\item The namespace for \primtype{SId} identifiers defined \emph{within}
  a \Model object used in Hierarchical Model Composition follows the
  same rules as those defined in SBML Level~3 Core for plain \Model
  objects.  That is, the scope of the identifiers is limited to the
  enclosing \Model object.  This means that two or more \Model objects
  in the same document may reuse the same object identifiers inside of
  them; the identifiers do not need to be unique at the level of the
  SBML document.  (For example, two model definitions could use the same
  \primtype{SId} value for \Parameter objects within their respective
  contents.  Note, however, that this does \emph{not} imply that the two
  objects are equated with each other!)  This is known as the
  \emph{object namespace of the model}.  An implication of this rule is
  that to fully locate an object, one must know not only the object's
  identifier, but also the identifier of the model in which it is
  located.

\item The identifier of every \UnitDefinition object must be unique
  across the set of all such identifiers in the \Model to which they
  belong.  (This is the same as in SBML Level~3 Version~1 Core.)  This
  namespace is referred to as the \emph{unit namespace of the model}.
  Similar to the case above, an implication of this rule is that to
  fully locate a user-defined unit definition when there are multiple
  models in an SBML document, one must know not only the unit
  definition's identifier, but also the identifier of the model in which
  it is located.

\item The Hierarchical Model Composition package defines a new kind of
  component: the \emph{port}, represented by \Port objects.  The
  identifier of every \Port object must be unique across the set of all
  such identifiers in the \Model object to which they belong.  Again, an
  implication of this rule is that to fully locate a port when there are
  multiple models in an SBML document, one must know not only the port's
  identifier, but also the identifier of the model in which it is
  located.

\item \Reaction objects introduce a local namespace for \LocalParameter
  objects.  These objects cannot be referenced from outside a given
  reaction definition.  For the Hierarchical Model Composition package,
  the implication is that the the \SBaseRef class
  (\sect{sbaseref-class}) cannot reference reaction local parameters
  simply by their identifiers (i.e., the value of their \token{id}
  attribute).  However, the \LocalParameter objects \emph{can} be given
  meta identifiers (a value for their \SBase-derived \token{metaid}
  attribute), and be referenced using those.

% FIXME need move this somewhere else:
% 
%   If replaced, it must be by an element in the normal element namespace of
%   a model (such as a global Parameter).  Old references to that replaced
%   LocalParameter will then point to the new replacement element.  If a
%   LocalParameter is deleted from a Reaction whose KineticLaw used it in
%   its math, that KineticLaw may still be valid if there was an element
%   in the element namespace of the model with that same id to which it
%   can now refer (in other words, if the LocalParameter shadowed a global
%   parameter).


\end{enumerate}

The following example may clarify some of these rules.  Suppose a given
SBML document contains a \Model object having the identifier \val{mod1}.
This \Model cannot contain another object with the same identifier
(e.g., it could not have a \Parameter object with the identifier
\val{mod1}), nor can there be any other \Model or
\ExternalModelDefinition objects identified as \val{mod1} within the
same SBML document.  The first restriction is simply the regular SBML
rule about uniqueness of identifiers throughout a \Model object; the
second restriction is due to point (1) above.  On the other hand, there
could be a second \Model object in the same document containing a
component (e.g., a \Parameter) with the identifier \val{mod1}.  This
would not conflict with the first \Model identifier (because the
\Parameter would be effectively hidden at a lower level within the
second \Model).


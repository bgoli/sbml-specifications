New things to change:

- if a name ends in 's', the listOf____s should not double the s at the end.

- explain abstract class

*****************************************************************************

Stuff left over from long ago:

%-----------------------------------------------------------------------------
\subsection{Approach to the XML Encoding}
%-----------------------------------------------------------------------------

XML is a tagged data representation format that consists of \emph{elements}
having values and (optionally) attributes.  The following piece of XML
illustrates the different parts of an XML representation:

\begin{quote}
  \begin{small}
    \tightspacing
\begin{verbatim}
<element1 attributeA="attributeA-value">element1-value</element1>

<element2 attributeB="attributeB-value" attributeC="attributeC-value">
  <element3>element3-value</element3>
  <element4 attributeD="attributeD-value">element4-value</element4>
</element2>
\end{verbatim}
    \regularspacing
  \end{small}
\end{quote}

The example above shows four separate elements.  Some of the elements have
attributes (\texttt{element1}, \texttt{element2}, \texttt{element4}), while
some do not (\texttt{element3}).  Some of the elements have simple values
(\texttt{element1}, \texttt{element3}, \texttt{element4}), while the other
one (\texttt{element2}) contains two other elements as its value.

Note that there is an unfortunate name collision between XML and UML: in
XML, an \emph{attribute} is specifically an annotation on an element,
whereas in UML an attribute is a field in a data structure.  When encoding
a UML data structure in XML, an attribute in the structure may or may not
be made into an XML element attribute---indeed, it is more likely to be
turned into an XML element.  For clarity, in this document, we use the term
\emph{element attribute} when referring to an attribute in an XML
representation.

One of the first questions that needs to be answered when developing an XML
format is: what should be stored as element attributes, and what should be
stored as element values?  A reasonable and easy-to-read book on XML and
XML style is \emph{XML Elements of Style}, by St.~Laurent (2000).  The
question of how element attributes and values ought to be used is addressed
on pp.~20--22.  Here are some of the tradeoffs:
\begin{itemize}
  
\item Both elements and element attributes are named containers for
  information.
  
\item Elements may contain other elements or text, whereas element
  attributes may contain only text.  Element attributes can be used as the
  equivalent of leaf elements.
  
\item Information can be written more compactly if expressed using element
  attributes rather than as separate elements nested within other elements.
  
\item The order of elements is always preserved, whereas the order of
  element attributes is not necessarily (it is parser
  implementation-dependent).
  
\item An element may have only one attribute of a given name, whereas an
  element may contain any number of child elements of the same name
  (assuming the particular Schema allows it).  The implication of this is
  that element attributes cannot be used to represent lists of structures.
  
\item The general convention is that that elements are for presentable
  content and element attributes for invisible annotations.  St.~Laurent
  writes: ``In general, the path of least resistance is to treat element
  content as 'real' content and reserve attributes for annotation of that
  content, or to reference content outside the element, like images or
  other documents'' (p.~21).
\end{itemize}

Therefore, although one could use either approach, it appears to be
technically more correct to use elements to store information and element
attributes to put annotations on the elements.  This is consistent with the
examples given in such official sources as the \emph{XML Schema Primer}
(Fallside, 2000).  The encoding we present in this document follows the
convention of using elements to represent UML object attributes.  This is
clarified in the example given in the next section and in the XML Schema
presented in Appendix~\ref{apdx:schemas}.

